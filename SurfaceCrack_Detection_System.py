# -*- coding: utf-8 -*-
"""ML_CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V9RB8Trrt5Q5wA7sb-_WhMo9F6LnXbIH
"""

import os

dataset_path = r"C:\Users\Vergin\cracks"  # Change this to your actual path
#print("Files in dataset:", os.listdir(dataset_path))  # List all files
d_n = r"C:\Users\Vergin\cracks\Positive"
d_p = r"C:\Users\Vergin\cracks\Negative"

#import os

#dataset_path = r"C:\Users\Dell\Downloads\cracks"  # Change this to your actual path
#print("Files in dataset:", os.listdir(dataset_path))  # List all files
#d_n = r"C:\Users\Dell\Downloads\cracks\Positive"
#d_p = r"C:\Users\Dell\Downloads\cracks\Negative"

from google.colab import drive
drive.mount('/content/drive')



for root, dirs, files in os.walk(d_n):
    print(f"Folder: {root}, Number of Files: {len(files)}")
    break  # Print only the first folder's content
for root, dirs, files in os.walk(d_p):
    print(f"Folder: {root}, Number of Files: {len(files)}")
    break  # Print only the first folder's content

import numpy as np
import pandas as pd
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

from tensorflow.keras.preprocessing.image import ImageDataGenerator

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras import Model,layers
import tensorflow as tf
import keras

import matplotlib.pyplot as plt
from matplotlib.image import imread
import cv2

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img = cv2.imread(os.path.join(folder,filename))
        if img is not None:
            images.append(img)
        if len(images)>3:
            break
    fig=plt.figure(figsize=(10,12))
    xrange=range(1,5)

    for img,x in zip(images,xrange):
        ax=fig.add_subplot(2,2,x)
        ax.imshow(img)
        ax.set_title(img.shape)

load_images_from_folder(r"C:\Users\Vergin\cracks\Positive")

load_images_from_folder(r"C:\Users\Dell\Downloads\cracks\Negative")

# Define a Callback class that stops training once accuracy reaches 99.9%
class myCallback(tf.keras.callbacks.Callback):
    def on_epoch_end(self, epoch, logs={}):
        if(logs.get('accuracy')>0.999):
            print("\nReached 98.0% accuracy so cancelling training!")
            self.model.stop_training = True

import h5py

local_weights_file = r"D:\inceptionv3\inception_v3_weights_tf_dim_ordering_tf_kernels.h5\inception_v3_weights_tf_dim_ordering_tf_kernels.h5"

try:
    with h5py.File(local_weights_file, 'r') as f:
        print("File opened successfully!")
except Exception as e:
    print("Error opening file:", e)

from tensorflow.keras.applications.inception_v3 import InceptionV3
local_weights_file = "./inception_v3_weights_tf_dim_ordering_tf_kernels_notop.h5"  # Ensure the correct file extension
pre_trained_model = InceptionV3(input_shape=(150, 150, 3),
                                include_top=False,
                                weights=None)
pre_trained_model.load_weights(local_weights_file)
for layer in pre_trained_model.layers:
    layer.trainable = False

last_layer = pre_trained_model.get_layer('mixed7')
last_output = last_layer.output
x = layers.Flatten()(last_output)
x = layers.Dense(1024, activation='relu')(x)
x = layers.Dropout(0.2)(x)
x = layers.Dense  (1, activation='sigmoid')(x)
model = Model(pre_trained_model.input, x)
model.compile(optimizer=RMSprop(learning_rate=0.0001),
              loss='binary_crossentropy',
              metrics=['accuracy'])

train_datagen = ImageDataGenerator(rescale = 1./255, validation_split=0.3)
train_generator = train_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                     target_size=(150,150),
                                                     batch_size=64,
                                                     shuffle=True,
                                                     class_mode='binary',
                                                     subset='training')

validation_datagen = ImageDataGenerator(rescale = 1./255, validation_split=0.3)
validation_generator =  validation_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                                target_size=(150,150),
                                                                batch_size=64,
                                                                class_mode='binary',
                                                                subset='validation')

callbacks = myCallback()
history = model.fit(train_generator,
            validation_data=validation_generator,
            epochs=7,
            verbose=1,
            callbacks=[callbacks])

import matplotlib.pyplot as plt
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(len(acc))
plt.plot(epochs, acc, 'r', label='Training accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
plt.title('Training and validation accuracy')
plt.figure()
plt.plot(epochs, loss, 'r', label='Training Loss')
plt.plot(epochs, val_loss, 'b', label='Validation Loss')
plt.title('Training and validation loss')
plt.legend()
plt.show()



import os
import numpy as np
import tensorflow as tf
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array
from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras import Model, layers
from tensorflow.keras.applications.inception_v3 import InceptionV3
from tkinter import Tk, filedialog

local_weights_file = "./inception_v3_weights_tf_dim_ordering_tf_kernels_notop.h5"
pre_trained_model = InceptionV3(input_shape=(150, 150, 3), include_top=False, weights=None)
pre_trained_model.load_weights(local_weights_file)

for layer in pre_trained_model.layers:
    layer.trainable = False

last_layer = pre_trained_model.get_layer('mixed7')
last_output = last_layer.output

x = layers.Flatten()(last_output)
x = layers.Dense(1024, activation='relu')(x)
x = layers.Dropout(0.2)(x)
x = layers.Dense(1, activation='sigmoid')(x)

model_vgg = Model(pre_trained_model.input, x)
model_vgg.compile(
    optimizer=RMSprop(learning_rate=0.0001),
    loss='binary_crossentropy',
    metrics=['accuracy']
)

train_datagen = ImageDataGenerator(rescale = 1./255, validation_split=0.3)

train_generator = train_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                     target_size=(150,150),
                                                     batch_size=64,
                                                     shuffle=True,
                                                     class_mode='binary',
                                                     subset='training')

validation_datagen = ImageDataGenerator(rescale = 1./255, validation_split=0.3)

validation_generator =  validation_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                                target_size=(150,150),
                                                                batch_size=64,
                                                                class_mode='binary',
                                                                subset='validation')

callbacks = myCallback()

history = model_vgg.fit(train_generator,
                                  validation_data = validation_generator,
                                  epochs = 7,
                                  verbose = 1,
                                  callbacks=[callbacks])

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs =AC range(len(acc))

plt.plot(epochs, acc, 'r', label='Training accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
plt.title('Training and validation accuracy')

plt.figure()

plt.plot(epochs, loss, 'r', label='Training Loss')
plt.plot(epochs, val_loss, 'b', label='Validation Loss')
plt.title('Training and validation loss')

plt.legend()

plt.show()

from tensorflow.keras.applications import ResNet50
from keras.applications.resnet50 import preprocess_input
from keras.models import Sequential
from keras.layers import Dense

train_datagen = ImageDataGenerator(validation_split=0.3,
                                   preprocessing_function=preprocess_input)
train_generator = train_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                     target_size=(224,224),
                                                     batch_size=64,
                                                     shuffle=True,
                                                     class_mode='categorical',
                                                     subset='training')

validation_datagen = ImageDataGenerator(validation_split=0.3,
                                        preprocessing_function=preprocess_input)
validation_generator =  validation_datagen.flow_from_directory(r"C:\Users\Dell\Downloads\cracks",
                                                                target_size=(224,224),
                                                                batch_size=64,
                                                                class_mode='categorical',
                                                                subset='validation')

model_res50 = Sequential()
model_res50.add(ResNet50(
    include_top=False,
    pooling='avg',
    weights='imagenet'
    ))
model_res50.add(Dense(2, activation='softmax'))
model_res50.layers[0].trainable = False
model_res50.summary()
steps_per_epoch_training = len(train_generator)
steps_per_epoch_validation = len(validation_generator)

callbacks = myCallback()
model_res50.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

fit_history = model_res50.fit(
    train_generator,
    steps_per_epoch=steps_per_epoch_training,
    validation_steps=steps_per_epoch_validation,
    epochs=7,
    validation_data=validation_generator,
    verbose=1,
    callbacks=[callbacks]
)

acc = fit_history.history['accuracy']
val_acc = fit_history.history['val_accuracy']
loss = fit_history.history['loss']
val_loss = fit_history.history['val_loss']
epochs = range(len(acc))
plt.plot(epochs, acc, 'r', label='Training accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
plt.title('Training and validation accuracy')
plt.figure()
plt.plot(epochs, loss, 'r', label='Training Loss')
plt.plot(epochs, val_loss, 'b', label='Validation Loss')
plt.title('Training and validation loss')
plt.legend()
plt.show()

from tensorflow.keras.preprocessing import image
from keras.applications.resnet50 import preprocess_input
import numpy as np
import matplotlib.pyplot as plt

img_path = input("Enter the path to the image: ").strip().strip('"').strip("'")

img = image.load_img(img_path, target_size=(224, 224))

plt.imshow(img)
plt.axis('off')
plt.title('Uploaded Image')
plt.show()

img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = preprocess_input(img_array)

prediction = model_res50.predict(img_array)
predicted_class = np.argmax(prediction)

if predicted_class == 0:
    print("Prediction: No Crack Detected ✅")
else:
    print("Prediction: Crack Detected ⚠️")

